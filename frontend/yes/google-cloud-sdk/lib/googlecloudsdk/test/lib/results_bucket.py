# Copyright 2015 Google Inc. All Rights Reserved.

"""Utility methods to aid in interacting with a GCS results bucket."""

import datetime

from googlecloudapis.apitools.base import py as apitools_base
from googlecloudsdk.calliope import exceptions
from googlecloudsdk.core import log
from googlecloudsdk.core.util.compat26 import subprocess
from googlecloudsdk.test.lib import exit_code
from googlecloudsdk.test.lib import util


def RunCommand(cmd):
  """Injectable command runner used for running shell commands (e.g. gsutil).

  Args:
    cmd: a list of strings which form the command when concatenated.

  Returns:
    A string holding the command output sent to stdout and stderr.

  Raises:
    ToolException: if the cmd was not runnable (e.g. gsutil is not installed).
      Note that gcloud commands need to catch all non-gcloud defined
      exceptions and either handle them or wrap them in a ToolException.
    subprocess.CalledProcessError: if the command's exit code is non-zero.
  """
  log.debug('Running command: {c}'.format(c=repr(cmd)))
  try:
    return subprocess.check_output(cmd, stderr=subprocess.STDOUT)
  except (OSError, ValueError) as err:
    raise exceptions.ToolException(err, exit_code=exit_code.INFRASTRUCTURE_ERR)


class ResultsBucketOps(object):
  """A utility class to encapsulate operations on the results bucket."""

  def __init__(self, project, bucket_name, tr_client, tr_messages,
               clock=datetime.datetime.now,
               cmd_runner=RunCommand,
               gsutil_cmd='gsutil'):
    """Construct a ResultsBucketOps object to be used with a single matrix run.

    Args:
      project: string containing the Google Developers Console project id.
      bucket_name: string containing the name of the GCS bucket.
      tr_client: ToolResults API client library generated by Apitools.
      tr_messages: ToolResults API messages library generated by Apitools.
      clock: injected function which will return a datetime object to be used
        as a timestamp for the test's results storage in GCS. We default to
        local time so the timestamp feels 'normal' to the user.
      cmd_runner: injected function which can run shell commands for us.
      gsutil_cmd: the path to the gsutil executable.
    """
    self._project = project
    self._cmd_runner = cmd_runner
    self._gsutil_cmd = gsutil_cmd

    # Get a current timestamp string in the format YYYY-MM-DD_hh:mm:ss.sss
    timestamp = clock().isoformat('_')[:-3]
    log.info('Test timestamp is {t}'.format(t=timestamp))

    # If the user supplied a results bucket, make sure it exists. Otherwise,
    # call the SettingsService to get the project's existing default bucket.
    if bucket_name:
      self.EnsureBucketExists(bucket_name)
    else:
      bucket_name = self._GetDefaultBucket(tr_client, tr_messages)

    self.gcs_results_root = 'gs://{b}/{t}/'.format(b=bucket_name, t=timestamp)
    self._gcs_results_url = (
        'https://console.developers.google.com/storage/browser/{b}/{t}/'
        .format(b=bucket_name, t=timestamp))

  def _GetDefaultBucket(self, tr_client, tr_messages):
    """Fetch the project's default GCS bucket name for storing tool results."""
    request = tr_messages.ToolresultsProjectsInitializeSettingsRequest(
        projectId=self._project)
    try:
      response = tr_client.projects.InitializeSettings(request)
      return response.defaultBucket
    except apitools_base.HttpError as error:
      msg = ('Http error while trying to fetch the default results bucket:\n{0}'
             .format(util.GetError(error)))
      raise exceptions.HttpException(msg)

  def EnsureBucketExists(self, bucket_name):
    """Create a GCS bucket if it doesn't already exist.

    Args:
      bucket_name: the name of the GCS bucket to create if it doesn't exist.

    Raises:
      BadFileException if the bucket name is malformed, the user does not
        have access rights to the bucket, or the bucket can't be created.
    """
    bucket_uri = 'gs://' + bucket_name
    bucket_exists_cmd = [self._gsutil_cmd, 'ls', '-b', bucket_uri]
    try:
      self._cmd_runner(bucket_exists_cmd)
      return  # The bucket exists and the user can access it.
    except subprocess.CalledProcessError as err:
      # Note: 'gsutil ls' can fail with exit code 1 for many reasons: the bucket
      # does not exist, the GCS URI is malformed, an access denied error, etc.
      # We must examine the exception output to distinguish the not-found case.
      # TODO(user): add a test to detect if the 'NotFound' message changes,
      # or consider changing the above check to use the GCS API directly.
      if 'NotFound' not in err.output:
        msg = ('{e}. Could not access [{b}]. Please supply a valid bucket name '
               'or use the default bucket provided by Cloud Test Lab.'
               .format(e=err.output.rstrip(), b=bucket_uri))
        raise exceptions.BadFileException(msg)

    # The bucket does not exist in any project, so create it in user's project.
    log.status.Print('Creating results bucket [{b}] in project [{p}].'
                     .format(b=bucket_uri, p=self._project))
    make_bucket_cmd = [self._gsutil_cmd, 'mb', '-p', self._project, bucket_uri]
    try:
      self._cmd_runner(make_bucket_cmd)
    except subprocess.CalledProcessError as err:
      raise exceptions.BadFileException(err.output)

  def UploadApkFileToGcs(self, apk):
    """Upload an APK file to the GCS results bucket.

    Note: The gsutil utility is used to perform the copy because it provides
    automatic retries and handles a wide variety of error conditions for us.

    Args:
      apk: str, the absolute or relative path of the APK file to upload.

    Raises:
      BadFileException if the file upload is not successful.
    """
    log.status.Print('Uploading {f} to the Cloud Test Lab...'.format(f=apk))
    upload_cmd = [self._gsutil_cmd, 'cp', apk, self.gcs_results_root]
    log.debug('Upload command: {cmd}'.format(cmd=' '.join(upload_cmd)))
    try:
      self._cmd_runner(upload_cmd)
    except subprocess.CalledProcessError as err:
      index = err.output.find('Exception:')
      details = err.output[index:].rstrip() if index >= 0 else ''
      raise exceptions.BadFileException(
          'Could not copy {f} to {gcs}. {d}'
          .format(f=apk, gcs=self.gcs_results_root, d=details))

  def LogGcsResultsUrl(self):
    log.status.Print('Raw results will be stored in your GCS bucket at [{0}].'
                     .format(self._gcs_results_url))
